import { SequenceIndexer, TokenBalance, ContractType } from '@0xsequence/indexer'
import { ChainId, networks, indexerURL } from '@0xsequence/network'
import { ethers } from 'ethers'

const getIndexerClient = (chainId: number) => {
  const network = networks[chainId as ChainId]
  return new SequenceIndexer(indexerURL(network.name))
}

interface GetTokenBalancesArgs {
  accountAddress: string
  chainId: number
}

export const getNativeTokenBalance = async ({ accountAddress, chainId }: GetTokenBalancesArgs) => {
  try {
    const indexerClient = getIndexerClient(chainId)

    const res = await indexerClient.getEtherBalance({ accountAddress })

    const tokenBalance: TokenBalance = {
      chainId,
      contractAddress: '0x0000000000000000000000000000000000000000',
      accountAddress,
      balance: res?.balance.balanceWei || '0',
      contractType: ContractType.UNKNOWN,
      blockHash: '',
      blockNumber: 0,
      tokenID: ''
    }
    return [tokenBalance]
  } catch (e) {
    console.error(e)
    return []
  }
}

export const getTokenBalances = async ({ accountAddress, chainId }: GetTokenBalancesArgs) => {
  try {
    const indexerClient = getIndexerClient(chainId)

    const res = await indexerClient.getTokenBalances({
      accountAddress,
      includeMetadata: true
    })

    return res?.balances || []
  } catch (e) {
    console.error(e)
    return []
  }
}

export const fetchBalances = async ({ accountAddress, chainId }: GetTokenBalancesArgs) => {
  try {
    const tokenBalances = (
      await Promise.all([
        getNativeTokenBalance({
          accountAddress,
          chainId
        }),
        getTokenBalances({
          accountAddress,
          chainId
        })
      ])
    ).flat()
    return tokenBalances
  } catch (e) {
    console.error(e)
    return []
  }
}

const DEVICE_EMOJIS = [
  // 256 emojis for unsigned byte range 0 - 255
  ...'ğŸ¶ğŸ±ğŸ­ğŸ¹ğŸ°ğŸ¦ŠğŸ»ğŸ¼ğŸ¨ğŸ¯ğŸ¦ğŸ®ğŸ·ğŸ½ğŸ¸ğŸµğŸ™ˆğŸ™‰ğŸ™ŠğŸ’ğŸ”ğŸ§ğŸ¦ğŸ¤ğŸ£ğŸ¥ğŸ¦†ğŸ¦…ğŸ¦‰ğŸ¦‡ğŸºğŸ—ğŸ´ğŸ¦„ğŸğŸ›ğŸ¦‹ğŸŒğŸğŸœğŸ¦ŸğŸ¦—ğŸ•·ğŸ•¸ğŸ¦‚ğŸ¢ğŸğŸ¦ğŸ¦–ğŸ¦•ğŸ™ğŸ¦‘ğŸ¦ğŸ¦ğŸ¦€ğŸ¡ğŸ ğŸŸğŸ¬ğŸ³ğŸ‹ğŸ¦ˆğŸŠğŸ…ğŸ†ğŸ¦“ğŸ¦ğŸ¦§ğŸ˜ğŸ¦›ğŸ¦ğŸªğŸ«ğŸ¦’ğŸ¦˜ğŸƒğŸ‚ğŸ„ğŸğŸ–ğŸğŸ‘ğŸ¦™ğŸğŸ¦ŒğŸ•ğŸ©ğŸ¦®ğŸˆğŸ“ğŸ¦ƒğŸ¦šğŸ¦œğŸ¦¢ğŸ¦©ğŸ•ŠğŸ‡ğŸ¦ğŸ¦¨ğŸ¦¡ğŸ¦¦ğŸ¦¥ğŸğŸ€ğŸ¿ğŸ¦”ğŸ¾ğŸ‰ğŸ²ğŸŒµğŸ„ğŸŒ²ğŸŒ³ğŸŒ´ğŸŒ±ğŸŒ¿ğŸ€ğŸğŸ‹ğŸƒğŸ‘£ğŸ‚ğŸğŸ„ğŸšğŸŒ¾ğŸ’ğŸŒ·ğŸŒ¹ğŸ¥€ğŸŒºğŸŒ¸ğŸŒ¼ğŸŒ»ğŸŒğŸŒğŸğŸğŸğŸŠğŸ‹ğŸŒğŸ‰ğŸ‡ğŸ“ğŸˆğŸ¥­ğŸğŸ¥¥ğŸ¥ğŸ…ğŸ¥‘ğŸ¥¦ğŸ¥¬ğŸ¥’ğŸŒ¶ğŸŒ½ğŸ¥•ğŸ§„ğŸ§…ğŸ¥”ğŸ ğŸ¥ğŸ¥¯ğŸğŸ¥–ğŸ¥¨ğŸ§€ğŸ¥šğŸ³ğŸ§ˆğŸ¥ğŸ§‡ğŸ¥“ğŸ¥©ğŸ—ğŸ–ğŸ¦´ğŸŒ­ğŸ”ğŸŸğŸ•ğŸ¥ªğŸ¥™ğŸ§†ğŸŒ®ğŸŒ¯ğŸ¥—ğŸ¥˜ğŸ¥«ğŸğŸœğŸ²ğŸ›ğŸ£ğŸ±ğŸ¥ŸğŸ¦ªğŸ¤ğŸ™ğŸšğŸ˜ğŸ¥ğŸ¥ ğŸ¥®ğŸ¢ğŸ¡ğŸ§ğŸ¨ğŸ¦ğŸ¥§ğŸ§ğŸ°ğŸ‚ğŸ®ğŸ­ğŸ¬ğŸ«ğŸ¿ğŸ©ğŸªğŸŒ°ğŸ¥œğŸ‘€ğŸ‘‚ğŸ‘ƒğŸ‘„ğŸ‘…ğŸ‘†ğŸ‘‡ğŸ‘ˆğŸ‘‰ğŸ‘ŠğŸ‘‹ğŸ‘ŒğŸ‘ğŸ‘ğŸ‘ğŸ‘ğŸ‘‘ğŸ‘’ğŸ‘“ğŸ¯ğŸ°ğŸ±ğŸ²ğŸ³ğŸ‘¾ğŸ‘¯ğŸ‘ºğŸ‘»ğŸ‘½ğŸ‚ğŸƒğŸ„'
]

// Generate a random name for the session, using a single random emoji and 2 random words
// from the list of words of ethers
export function randomName() {
  const wordlistSize = 2048
  const words = ethers.wordlists.en

  const randomEmoji = DEVICE_EMOJIS[Math.floor(Math.random() * DEVICE_EMOJIS.length)]
  const randomWord1 = words.getWord(Math.floor(Math.random() * wordlistSize))
  const randomWord2 = words.getWord(Math.floor(Math.random() * wordlistSize))

  return `${randomEmoji} ${randomWord1} ${randomWord2}`
}
